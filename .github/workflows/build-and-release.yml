name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0
  workflow_dispatch:  # Allow manual triggering

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Python (for native module builds)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'  # Python 3.11 has distutils, needed for node-gyp

      - name: Install Python setuptools (for distutils compatibility)
        run: |
          python -m pip install --upgrade pip
          pip install setuptools

      - name: Install dependencies
        run: npm ci

      - name: Rebuild native modules
        run: npm run rebuild || echo "Rebuild failed, electron-builder will handle it"
        continue-on-error: true

      - name: Import code signing certificate
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
        if: env.CSC_LINK != ''
        run: |
          if [ -n "$CSC_LINK" ]; then
            echo "ðŸ“¦ Importing code signing certificate..."
            
            # Clean up any existing keychain from previous runs
            security delete-keychain build.keychain 2>/dev/null || true
            
            # Create keychain
            security create-keychain -p "" build.keychain
            security list-keychains -s build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p "" build.keychain
            security set-keychain-settings -t 3600 -u build.keychain
            
            # Decode and save certificate to file (electron-builder can use file path)
            echo "$CSC_LINK" | base64 --decode > certificate.p12
            
            # Verify certificate file was created
            if [ ! -f "certificate.p12" ]; then
              echo "âŒ Failed to decode certificate"
              exit 1
            fi
            
            # Import certificate into keychain
            if ! security import certificate.p12 -k build.keychain -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security; then
              echo "âŒ Failed to import certificate into keychain"
              exit 1
            fi
            
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain || true
            
            # Find and display the certificate identity name
            echo "ðŸ” Available signing identities:"
            security find-identity -v -p codesigning build.keychain
            
            # Extract the identity name (usually "Developer ID Application: ...")
            # electron-builder wants just the name part, not the prefix
            FULL_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | cut -d'"' -f2)
            if [ -n "$FULL_IDENTITY" ]; then
              echo "âœ… Found identity: $FULL_IDENTITY"
              # Remove "Developer ID Application: " prefix if present
              IDENTITY_NAME=$(echo "$FULL_IDENTITY" | sed 's/^Developer ID Application: //')
              echo "âœ… Using identity name (without prefix): $IDENTITY_NAME"
              echo "CSC_NAME=$IDENTITY_NAME" >> $GITHUB_ENV
              
              # Verify the identity can be used for signing
              if security find-identity -v -p codesigning build.keychain | grep -q "$FULL_IDENTITY"; then
                echo "âœ… Identity verified and ready for signing"
              else
                echo "âš ï¸  Warning: Identity found but verification check failed"
              fi
            else
              echo "âŒ Could not find Developer ID Application identity"
              echo "Available identities:"
              security find-identity -v -p codesigning build.keychain
              exit 1
            fi
            
            # Clean up certificate file (security best practice)
            rm -f certificate.p12
          fi

      - name: Build macOS installer
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Code signing and notarization
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
          CSC_IDENTITY_AUTO_DISCOVERY: false
          CSC_INSTALL_KEYCHAIN_NAME: "build.keychain"
        run: |
          # Recreate certificate file for electron-builder (it was cleaned up after import)
          if [ -n "$CSC_LINK" ] && [ ! -f "certificate.p12" ]; then
            echo "ðŸ“¦ Recreating certificate file for electron-builder..."
            echo "$CSC_LINK" | base64 --decode > certificate.p12
          fi
          
          # Set CSC_LINK to the certificate file path (electron-builder prefers file paths)
          if [ -f "certificate.p12" ]; then
            export CSC_LINK="$(pwd)/certificate.p12"
            echo "âœ… Using certificate file: $CSC_LINK"
          fi
          
          # Use CSC_NAME if we found the identity
          if [ -n "$CSC_NAME" ]; then
            export CSC_NAME="$CSC_NAME"
            echo "âœ… Using identity name: $CSC_NAME"
          fi
          # Export environment variables for notarization (electron-builder needs these)
          export APPLE_ID="$APPLE_ID"
          export APPLE_APP_SPECIFIC_PASSWORD="$APPLE_APP_SPECIFIC_PASSWORD"
          export APPLE_TEAM_ID="$APPLE_TEAM_ID"
          
          # Verify notarization credentials are set
          if [ -n "$APPLE_ID" ] && [ -n "$APPLE_APP_SPECIFIC_PASSWORD" ] && [ -n "$APPLE_TEAM_ID" ]; then
            echo "âœ… Notarization credentials found"
            echo "   APPLE_ID: ${APPLE_ID:0:3}*** (hidden)"
            echo "   APPLE_TEAM_ID: $APPLE_TEAM_ID"
            echo "   APPLE_APP_SPECIFIC_PASSWORD: ${APPLE_APP_SPECIFIC_PASSWORD:0:3}*** (hidden)"
            
            # Test notarization credentials by checking if we can authenticate
            echo "ðŸ” Testing notarization credentials..."
            if xcrun notarytool store-credentials --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" test-profile 2>&1 | grep -q "Success\|already exists"; then
              echo "âœ… Notarization credentials are valid"
              xcrun notarytool store-credentials --delete test-profile 2>/dev/null || true
            else
              echo "âš ï¸  Warning: Could not verify notarization credentials"
              echo "   This might cause notarization to fail, but signing should still work"
            fi
          else
            echo "âš ï¸  Notarization credentials missing - app will be signed but not notarized"
          fi
          
          # Verify signing setup
          if [ -z "$CSC_LINK" ]; then
            echo "âš ï¸  Code signing skipped - CSC_LINK not set. Building unsigned app."
            npm run build:mac -- --publish never
          else
            echo "âœ… Code signing and notarization enabled - building signed and notarized app"
            echo "ðŸ“‹ Signing configuration:"
            echo "   CSC_LINK: $CSC_LINK"
            echo "   CSC_NAME: ${CSC_NAME:-not set}"
            echo "   CSC_INSTALL_KEYCHAIN_NAME: $CSC_INSTALL_KEYCHAIN_NAME"
            echo "   APPLE_TEAM_ID: $APPLE_TEAM_ID"
            
            # Temporarily update package.json to include teamId in notarize config
            # electron-builder's notarization needs explicit teamId
            if [ -n "$APPLE_TEAM_ID" ]; then
              echo "ðŸ“ Updating package.json with teamId for notarization..."
              # Use node to properly update JSON
              node -e "
                const fs = require('fs');
                const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                pkg.build.mac.notarize = { teamId: process.env.APPLE_TEAM_ID };
                fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
                console.log('âœ… Updated notarize config with teamId:', process.env.APPLE_TEAM_ID);
              "
            fi
            
            # Build (notarization can take 10-20 minutes)
            # Note: GitHub Actions has a default timeout of 6 hours, which is sufficient
            echo "ðŸš€ Starting build process (this may take 15-20 minutes with notarization)..."
            
            # Set debug flags for better error visibility
            export DEBUG=electron-notarize:*
            export ELECTRON_BUILDER_CACHE=/tmp/electron-builder-cache
            
            # Try building with better error handling
            if ! npm run build:mac -- --publish never 2>&1 | tee build.log; then
              echo "âŒ Build failed. Checking logs..."
              echo "Last 50 lines of build output:"
              tail -50 build.log || cat build.log
              
              # Check if it's a notarization error
              if grep -q "not valid JSON\|notarization\|notarytool" build.log; then
                echo ""
                echo "âš ï¸  Notarization error detected. This might be:"
                echo "   - Network issue with Apple's servers"
                echo "   - Invalid credentials"
                echo "   - Rate limiting"
                echo "   - Service temporarily unavailable"
                echo ""
                echo "The app may still be signed correctly. Check the verification step."
              fi
              
              exit 1
            fi
            
            echo "âœ… Build completed successfully"
          fi

      - name: Verify code signing and notarization
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
        if: env.CSC_LINK != ''
        run: |
          set -e
          
          # Find the DMG file (check both dist/ and dist/mac/)
          DMG_FILE=$(find dist -name "*.dmg" -type f | head -1)
          if [ -z "$DMG_FILE" ]; then
            echo "âš ï¸  No DMG file found in dist/, checking dist/mac/..."
            ls -la dist/ || echo "dist/ directory does not exist"
            ls -la dist/mac/ 2>/dev/null || echo "dist/mac/ directory does not exist"
            
            # Try to find any DMG in the workspace
            DMG_FILE=$(find . -name "*.dmg" -type f 2>/dev/null | head -1)
            if [ -z "$DMG_FILE" ]; then
              echo "âŒ No DMG file found anywhere in the workspace"
              exit 1
            else
              echo "âœ… Found DMG file: $DMG_FILE"
            fi
          fi
          
          echo "ðŸ“¦ DMG file: $DMG_FILE"
          echo "ðŸ“Š DMG size: $(du -h "$DMG_FILE" | cut -f1)"
          
          # Mount the DMG to check the app
          MOUNT_POINT="/tmp/dmg_mount_$$"
          mkdir -p "$MOUNT_POINT"
          
          if ! hdiutil attach "$DMG_FILE" -quiet -nobrowse -mountpoint "$MOUNT_POINT"; then
            echo "âŒ Failed to mount DMG"
            exit 1
          fi
          
          # Find the app inside the DMG
          APP_PATH=$(find "$MOUNT_POINT" -name "*.app" -type d | head -1)
          
          if [ -z "$APP_PATH" ]; then
            echo "âŒ No app found in DMG"
            hdiutil detach "$MOUNT_POINT" -quiet || true
            exit 1
          fi
          
          echo "ðŸ“± App path: $APP_PATH"
          
          # Verify code signing with detailed output
          echo ""
          echo "ðŸ” Verifying code signature..."
          if codesign -vvv --deep --strict "$APP_PATH" 2>&1; then
            echo "âœ… Code signature is valid"
          else
            echo "âŒ Code signature verification failed"
            hdiutil detach "$MOUNT_POINT" -quiet || true
            exit 1
          fi
          
          # Check signature details
          echo ""
          echo "ðŸ“‹ Signature details:"
          codesign -d -vv "$APP_PATH" 2>&1 | head -20
          
          # Check notarization ticket
          echo ""
          echo "ðŸŽ« Checking notarization ticket..."
          if stapler validate "$APP_PATH" 2>&1; then
            echo "âœ… Notarization ticket is stapled"
          else
            echo "âš ï¸  Notarization ticket not found or not stapled"
            echo "   This may be normal if notarization is still processing"
          fi
          
          # Check Gatekeeper assessment
          echo ""
          echo "ðŸ›¡ï¸  Checking Gatekeeper assessment..."
          if spctl -a -vv "$APP_PATH" 2>&1; then
            echo "âœ… Gatekeeper assessment passed - app is trusted"
          else
            echo "âš ï¸  Gatekeeper assessment failed or pending"
            echo "   This may be normal if notarization is still processing"
          fi
          
          # Check for quarantine attribute (should not be present)
          echo ""
          echo "ðŸ”’ Checking quarantine attribute..."
          if xattr -l "$APP_PATH" 2>/dev/null | grep -q "com.apple.quarantine"; then
            echo "âš ï¸  Quarantine attribute found (unexpected for signed/notarized app)"
          else
            echo "âœ… No quarantine attribute (expected for signed/notarized app)"
          fi
          
          # Unmount
          hdiutil detach "$MOUNT_POINT" -quiet || true
          
          echo ""
          echo "âœ… Verification complete"

      - name: Cleanup keychain
        if: always()
        run: |
          # Clean up keychain even if build fails
          security delete-keychain build.keychain 2>/dev/null || true
          echo "ðŸ§¹ Cleaned up build keychain"

      - name: List dist directory
        run: ls -la dist/ || echo "dist directory not found"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mac-installer
          path: |
            dist/*.dmg
            dist/mac/*.dmg
          retention-days: 30
          if-no-files-found: warn

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write  # Required to create releases and upload assets
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: |
          echo "Artifacts directory contents:"
          ls -la artifacts/ || echo "artifacts directory not found"
          echo "mac-installer directory contents:"
          ls -la artifacts/mac-installer/ || echo "mac-installer directory not found"

      - name: Create Release and Upload Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          
          # Find DMG file
          DMG_FILE=$(find ./artifacts -name "*.dmg" -type f | head -1)
          
          if [ -z "$DMG_FILE" ]; then
            echo "No DMG file found in artifacts"
            exit 1
          fi
          
          echo "Found DMG file: $DMG_FILE"
          
          # Create or update release
          if gh release view "$TAG_NAME" > /dev/null 2>&1; then
            echo "Release $TAG_NAME already exists, uploading asset..."
            gh release upload "$TAG_NAME" "$DMG_FILE" --clobber
          else
            echo "Creating new release $TAG_NAME..."
            gh release create "$TAG_NAME" \
              --title "Release $TAG_NAME" \
              --notes "Dante Audio Client Release $TAG_NAME" \
              "$DMG_FILE"
          fi

